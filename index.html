<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>çŒ«çŒ«æŠ•å–‚æœº</title>
    <style>
        /* ============ å…¨å±€æ ·å¼è®¾ç½® ============ */
        body { 
            /* å¼•ç”¨æœ¬åœ°èƒŒæ™¯å›¾ */
            background-image: url('bg3.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            
            color: #667; 
            font-family: 'Comic Sans MS', 'YouYuan', 'Microsoft YaHei', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            margin: 0; 
            overflow: hidden; 
        }

        /* ============ ä¸»å®¹å™¨ ============ */
        .container { 
            background: rgba(255, 255, 255, 0.96); 
            padding: 90px 50px 50px 50px; /* é¡¶éƒ¨ç•™ç™½æ›´å¤šç»™è´è¶ç»“ */
            border: 4px solid #bce0ff; 
            border-radius: 40px; 
            box-shadow: 0 0 40px rgba(130, 190, 255, 0.6), inset 0 0 30px rgba(255, 255, 255, 0.9);
            width: 480px; 
            text-align: center; 
            position: relative; 
            z-index: 10; /* ä¿è¯åœ¨é›ªèŠ±å‰é¢ */
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            backdrop-filter: blur(5px);
        }

        .container:hover {
            transform: translateY(-8px);
        }

        /* ============ åŠ¨æ€çŒ«è€³ (ä¿æŒå¯çˆ±æ™ƒåŠ¨) ============ */
        .ear {
            position: absolute;
            top: -45px;
            width: 90px;
            height: 90px;
            background: #fff;
            border: 4px solid #bce0ff;
            border-bottom: none;
            z-index: -2; /* æ”¾åœ¨è´è¶ç»“åé¢ */
            border-radius: 80% 20% 50% 50% / 100% 100% 0 0; 
            box-shadow: 0 -5px 15px rgba(160, 207, 255, 0.3);
            transform-origin: bottom center;
        }

        .ear::after {
            content: '';
            position: absolute;
            top: 15px;
            width: 50%;
            height: 60%;
            background: radial-gradient(circle at 50% 30%, #ffebef, #ffdae0);
            border-radius: 50% 50% 50% 50% / 80% 80% 20% 20%;
            opacity: 0.9;
        }

        .ear.left {
            left: 30px;
            transform: rotate(-20deg);
            border-radius: 60% 90% 0 0;
            animation: earWiggleLeft 4s infinite ease-in-out;
        }
        .ear.left::after { left: 20%; transform: rotate(5deg); }

        .ear.right {
            right: 30px;
            transform: rotate(20deg);
            border-radius: 90% 60% 0 0;
            animation: earWiggleRight 5s infinite ease-in-out;
        }
        .ear.right::after { right: 20%; transform: rotate(-5deg); }

        @keyframes earWiggleLeft { 0%, 100% { transform: rotate(-20deg); } 50% { transform: rotate(-25deg); } }
        @keyframes earWiggleRight { 0%, 100% { transform: rotate(20deg); } 50% { transform: rotate(25deg); } }

        /* ============ é«˜å®šç‰ˆä¸ç»¸è´è¶ç»“ (CSS Art) ============ */
        .bow-container {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px; /* æ›´å¤§ */
            height: 80px;
            z-index: 20;
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.15)); /* æ•´ä½“æŠ•å½± */
        }

        /* è´è¶ç»“å·¦å³ç¿…è†€ */
        .bow-wing {
            position: absolute;
            top: 0;
            width: 70px;
            height: 60px;
            background: linear-gradient(135deg, #ff9eb5 0%, #ff7597 50%, #ff5c86 100%);
            border-radius: 20px 20px 30px 30px;
        }
        .bow-wing.left {
            left: 0;
            transform: skewX(15deg) rotate(-10deg);
            border-radius: 50% 10% 20% 50%;
            background: radial-gradient(circle at 20% 20%, #ffcad7, #ff7597);
        }
        .bow-wing.right {
            right: 0;
            transform: skewX(-15deg) rotate(10deg);
            border-radius: 10% 50% 50% 20%;
            background: radial-gradient(circle at 80% 20%, #ffcad7, #ff7597);
        }
        
        /* è´è¶ç»“ä¸­é—´çš„ç»“ */
        .bow-knot {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: linear-gradient(to bottom right, #ffb3c6, #ff4d79);
            border-radius: 40%;
            z-index: 22;
            box-shadow: inset 0 0 5px rgba(255,255,255,0.5), 0 2px 5px rgba(0,0,0,0.2);
        }

        /* é“ƒé“› (æœ‰çº¹ç†ç‰ˆ) */
        .bell {
            position: absolute;
            bottom: -30px; /* æŒ‚åœ¨ç»“ä¸‹é¢ */
            left: 50%;
            transform: translateX(-50%);
            width: 32px;
            height: 32px;
            /* é»„é‡‘é‡‘å±æ¸å˜ */
            background: radial-gradient(circle at 30% 30%, #fffbe0 0%, #ffd700 20%, #daa520 80%, #8b6914 100%);
            border-radius: 50%;
            border: 1px solid #b8860b;
            z-index: 21;
            animation: bellSwing 3s infinite ease-in-out;
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        }
        
        /* é“ƒé“›çš„å¼€å£ */
        .bell::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 3px;
            background: #5c4002;
            border-radius: 5px;
            opacity: 0.6;
        }
        /* é“ƒé“›é‡Œé¢çš„ç å­ */
        .bell::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        @keyframes bellSwing { 
            0%, 100% { transform: translateX(-50%) rotate(5deg); } 
            50% { transform: translateX(-50%) rotate(-5deg); } 
        }

        /* ============ è£…é¥°æ˜Ÿæ˜Ÿ ============ */
        .star-deco {
            position: absolute;
            font-size: 24px;
            color: #ffd700;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
            animation: twinkle 2s infinite alternate;
        }
        .star-1 { top: 80px; left: 60px; animation-delay: 0s; }
        .star-2 { top: 70px; right: 60px; font-size: 18px; animation-delay: 1s; }
        @keyframes twinkle { 0% { opacity: 0.5; transform: scale(0.8) rotate(0deg); } 100% { opacity: 1; transform: scale(1.2) rotate(45deg); } }

        /* ============ æ ‡é¢˜ ============ */
        h1 { 
            color: #8ec5ff; 
            font-size: 2rem; 
            margin-bottom: 30px; 
            text-shadow: 2px 2px 0px #fff, 3px 3px 0px #d4eaff;
            font-weight: 800;
            margin-top: 10px;
        }

        /* ============ ä¸Šä¼ åŒºåŸŸ ============ */
        .upload-area { 
            display: block;
            padding: 35px 25px; 
            border: 4px dashed #e6c6a8; 
            border-radius: 60px; 
            cursor: pointer; 
            margin-bottom: 40px; 
            background-color: #fffdf5;
            color: #a89480;
            font-weight: bold;
            font-size: 1.1rem;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover { 
            border-color: #ffb7b2; 
            background-color: #fff0f5;
            color: #ff8fa3;
            transform: scale(1.02);
        }

        /* ============ æŒ‰é’® (è¶…ç²¾è‡´çŒ«çˆªç‰ˆ) ============ */
        button#processBtn { 
            background: linear-gradient(135deg, #a0cfff 0%, #8ec5ff 100%);
            color: #fff; 
            border: none; 
            padding: 0;
            border-radius: 40px; 
            width: 100px; 
            height: 90px;
            cursor: pointer; 
            box-shadow: 0 8px 20px rgba(142, 197, 255, 0.4), inset 0 2px 5px rgba(255,255,255,0.4);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            position: relative;
            top: 10px;
        }

        button#processBtn:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 15px 30px rgba(142, 197, 255, 0.6);
            background: linear-gradient(135deg, #8ec5ff 0%, #7abaff 100%);
        }

        button#processBtn:active { transform: scale(0.95); }

        button#processBtn:disabled {
            background: #e0e0e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            filter: grayscale(100%);
        }

        /* éšè—åŸæ¥çš„æµ‹è¯•æŒ‰é’® */
        button[onclick="testRoundTrip()"] { display: none; }

        .paw-icon {
            width: 55px;
            height: 55px;
            fill: #fff;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
        }

        input[type="file"] { display: none; }

        /* ============ çŠ¶æ€æç¤º ============ */
        .status {
            margin-top: 30px;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 0.95rem;
            display: none;
            font-weight: bold;
        }
        .status.success { background: #e6fffa; color: #2c7a7b; border: 2px solid #b2f5ea; }
        .status.error { background: #fff5f5; color: #c53030; border: 2px solid #fed7d7; }

        /* ============ çœŸå®æ„Ÿè½é›ªç‰¹æ•ˆ ============ */
        #snow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1; /* å®¹å™¨åé¢ï¼ŒèƒŒæ™¯å‰é¢ */
        }

        .snowflake {
            position: absolute;
            background: #fff;
            border-radius: 50%; /* åœ†å½¢é›ªèŠ± */
            opacity: 0.8;
            box-shadow: 0 0 5px rgba(255,255,255,0.8); /* å¾®å¾®å‘å…‰ */
        }

        /* å‚ç›´ä¸‹è½ */
        @keyframes fall {
            0% { top: -10%; }
            100% { top: 110%; }
        }

        /* æ°´å¹³æ‘‡æ‘† (æ¨¡æ‹Ÿé£) */
        @keyframes sway {
            0% { transform: translateX(0); }
            50% { transform: translateX(20px); } /* æ‘†åŠ¨å¹…åº¦ */
            100% { transform: translateX(0); }
        }

    </style>
</head>
<body>
    <div id="snow-container"></div>

    <div class="container">
        <div class="ear left"></div>
        <div class="ear right"></div>
        
        <div class="bow-container">
            <div class="bow-wing left"></div>
            <div class="bow-wing right"></div>
            <div class="bow-knot">
                <div class="bell"></div>
            </div>
        </div>
        
        <div class="star-deco star-1">âœ¨</div>
        <div class="star-deco star-2">âœ¨</div>

        <h1>çŒ«çŒ«æŠ•å–‚æœº</h1>
        
        <label for="fileInput" class="upload-area" id="dropArea">
            ğŸ“‚ ç‚¹å‡»ä¸Šä¼  JSON è§’è‰²å¡
        </label>
        
        <input type="file" id="fileInput" accept=".json">
        
        <button onclick="processCard()" id="processBtn" title="ç”Ÿæˆå…«å±‚åŠ å¯†æ ¸å¿ƒ">
            <svg class="paw-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12,13.5c-2.3,0-4.3,1.6-4.8,3.9c-0.2,0.9,0.1,1.9,0.9,2.5c0.7,0.6,1.7,0.7,2.6,0.2c0.4-0.2,0.8-0.3,1.3-0.3
                s0.9,0.1,1.3,0.3c0.9,0.5,1.9,0.4,2.6-0.2c0.7-0.6,1.1-1.6,0.9-2.5C16.3,15.1,14.3,13.5,12,13.5z"/>
                <path d="M5.6,12.2c1.7,0,3-1.7,3-3.8s-1.4-3.8-3-3.8c-1.7,0-3,1.7-3,3.8S4,12.2,5.6,12.2z"/>
                <path d="M12,10.2c1.7,0,3.1-1.7,3.1-3.9c0-2.1-1.4-3.9-3.1-3.9S8.9,4.2,8.9,6.4C8.9,8.5,10.3,10.2,12,10.2z"/>
                <path d="M18.4,12.2c1.7,0,3-1.7,3-3.8s-1.4-3.8-3-3.8c-1.7,0-3,1.7-3,3.8S16.7,12.2,18.4,12.2z"/>
                <path d="M2.5,16.5c1.4,0,2.5-1.4,2.5-3.1s-1.1-3.1-2.5-3.1S0,11.7,0,13.4S1.1,16.5,2.5,16.5z"/>
                <path d="M21.5,16.5c1.4,0,2.5-1.4,2.5-3.1s-1.1-3.1-2.5-3.1s-2.5,1.4-2.5,3.1S20.1,16.5,21.5,16.5z"/>
            </svg>
        </button>
        
        <button onclick="testRoundTrip()" style="margin-top: 10px; background: #ff9d00;">ğŸ§ª æµ‹è¯•å¾€è¿”åŠ å¯†</button>
        
        <div class="status" id="status"></div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('dropArea');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', function() {
            if (this.files[0]) {
                dropArea.innerHTML = "å·²æ•æ‰: <strong>" + this.files[0].name + "</strong> ğŸ¾";
                dropArea.style.borderColor = "#a0cfff";
                dropArea.style.color = "#a0cfff";
                processBtn.disabled = false;
            }
        });

        function showStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + (isError ? 'error' : 'success');
        }

        // ============ å·¥å…·å‡½æ•° ============
        function bytesToString(bytes) {
            const CHUNK_SIZE = 8192;
            let result = '';
            const arr = bytes instanceof Uint8Array ? bytes : 
                        (bytes instanceof Uint16Array ? bytes : Array.from(bytes));
            for (let i = 0; i < arr.length; i += CHUNK_SIZE) {
                const end = Math.min(i + CHUNK_SIZE, arr.length);
                const chunk = [];
                for (let j = i; j < end; j++) {
                    chunk.push(arr[j]);
                }
                result += String.fromCharCode.apply(null, chunk);
            }
            return result;
        }

        function generateKey(layerIndex, length) {
            const seed = 3141592653 + layerIndex * 1000007;
            const key = new Uint8Array(length);
            for (let i = 0; i < length; i++) {
                let x = ((seed >>> 0) + (i * 2654435761 >>> 0)) >>> 0;
                x = (x ^ (x >>> 13)) >>> 0;
                x = (x ^ (x << 17)) >>> 0;
                x = (x ^ (x >>> 5)) >>> 0;
                key[i] = x & 255;
            }
            return key;
        }

        function generateFibonacci(length) {
            const maxLen = Math.min(length, 1000);
            const fib = [1, 1];
            while (fib.length < maxLen) {
                const next = (fib[fib.length - 1] + fib[fib.length - 2]) % 1000000007;
                fib.push(next);
            }
            return fib.slice(0, maxLen);
        }

        // ============ å…«å±‚åŠ å¯†å‡½æ•° ============
        function byteTransformForward(str, layerIndex) {
            const bytes = new TextEncoder().encode(str);
            const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
            const step1 = new Uint8Array(bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                let byte = bytes[i];
                const positionFactor = (i * 13) % 256;
                byte ^= positionFactor;
                const prime = primes[i % primes.length];
                const layerFactor = (layerIndex + 1) * 17;
                byte = (byte + prime + layerFactor) % 256;
                const shift = (i % 7) + 1;
                byte = ((byte << shift) | (byte >> (8 - shift))) & 0xFF;
                step1[i] = byte;
            }
            const result = new Uint8Array(bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                let byte = step1[i];
                if (i > 0) {
                    byte ^= step1[i - 1] & 0x0F;
                    byte ^= result[i - 1] & 0xF0;
                }
                result[i] = byte;
            }
            return result;
        }
        
        function encodeEightLayers(jsonData) {
            try {
                const dataWithMeta = {
                    ...jsonData,
                    _format: 'HAKIMI_8LAYER',
                    _version: 'v12.1',
                    _timestamp: 1234567890000,
                    _encoder: 'Hakimi_Encoder',
                    _watermark: 'Protected'
                };
                let result = JSON.stringify(dataWithMeta);
                console.log("[Hakimi] ğŸš€ å¼€å§‹å…«å±‚åŠ å¯†...");
                let multiByteCount = 0;
                for (let i = 0; i < result.length; i++) {
                    if (result.charCodeAt(i) > 127) multiByteCount++;
                }
                result = byteTransformForward(result, 0);
                result = matrixTransformForward(result, 1);
                result = fibonacciShuffle(result, 2);
                result = xorChainForward(result, 3);
                result = railFenceCipher(result, 4);
                result = base91Encode(result);
                result = addChecksum(result);
                result = '=== DATA START ===\n' + result + '\n=== DATA END ===';
                return result;
            } catch (e) {
                console.error("[Hakimi] âŒ åŠ å¯†å¤±è´¥:", e);
                return null;
            }
        }

        function matrixTransformForward(input, layerIndex) {
            const matrixSize = 5;
            const bytes = input;
            const paddedLength = Math.ceil(bytes.length / (matrixSize * matrixSize)) * (matrixSize * matrixSize);
            const paddedBytes = new Uint8Array(paddedLength);
            paddedBytes.set(bytes);
            const result = new Uint8Array(paddedLength);
            const matrixCount = paddedLength / (matrixSize * matrixSize);
            const transformationMatrix = [
                [3, 5, 7, 11, 13], [17, 19, 23, 29, 31], [37, 41, 43, 47, 53], [59, 61, 67, 71, 73], [79, 83, 89, 97, 101]
            ];
            const multipliers = [
                [3, 5, 7, 9, 11], [13, 15, 17, 19, 21], [23, 25, 27, 29, 31], [33, 35, 37, 39, 41], [43, 45, 47, 49, 51]
            ];
            for (let m = 0; m < matrixCount; m++) {
                const startIdx = m * matrixSize * matrixSize;
                const matrix = new Array(matrixSize).fill(0).map(() => new Array(matrixSize).fill(0));
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        matrix[i][j] = paddedBytes[startIdx + i * matrixSize + j];
                    }
                }
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = i + 1; j < matrixSize; j++) {
                        [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
                    }
                }
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        let val = matrix[i][j];
                        val = (val + transformationMatrix[i][j]) % 256;
                        val = (val * multipliers[i][j]) % 256;
                        matrix[i][j] = val;
                    }
                }
                const rotated = spiralRotate(matrix);
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        result[startIdx + i * matrixSize + j] = rotated[i][j];
                    }
                }
            }
            return result;
        }

        function spiralRotate(matrix) {
            const size = matrix.length;
            const result = new Array(size).fill(0).map(() => new Array(size).fill(0));
            let top = 0, bottom = size - 1, left = 0, right = size - 1;
            let values = [];
            while (top <= bottom && left <= right) {
                for (let i = left; i <= right; i++) values.push(matrix[top][i]);
                top++;
                for (let i = top; i <= bottom; i++) values.push(matrix[i][right]);
                right--;
                if (top <= bottom) {
                    for (let i = right; i >= left; i--) values.push(matrix[bottom][i]);
                    bottom--;
                }
                if (left <= right) {
                    for (let i = bottom; i >= top; i--) values.push(matrix[i][left]);
                    left++;
                }
            }
            values = values.reverse();
            let index = 0;
            top = 0; bottom = size - 1; left = 0; right = size - 1;
            while (top <= bottom && left <= right && index < values.length) {
                for (let i = left; i <= right && index < values.length; i++) result[top][i] = values[index++];
                top++;
                for (let i = top; i <= bottom && index < values.length; i++) result[i][right] = values[index++];
                right--;
                if (top <= bottom) {
                    for (let i = right; i >= left && index < values.length; i--) result[bottom][i] = values[index++];
                    bottom--;
                }
                if (left <= right) {
                    for (let i = bottom; i >= top && index < values.length; i--) result[i][left] = values[index++];
                    left++;
                }
            }
            return result;
        }

        function fibonacciShuffle(input, layerIndex) {
            const len = input.length;
            const chars = new Uint8Array(input);
            const fibLen = Math.min(len, 1000);
            const fib = generateFibonacci(fibLen);
            for (let round = 0; round < 3; round++) {
                for (let i = 1; i < len; i++) {
                    const fibIndex = i % fib.length;
                    const swapWith = (i + fib[fibIndex]) % len;
                    if (swapWith !== i) {
                        const temp = chars[i];
                        chars[i] = chars[swapWith];
                        chars[swapWith] = temp;
                    }
                }
            }
            return chars;
        }

        function xorChainForward(input, layerIndex) {
            const bytes = input;
            const key = generateKey(layerIndex, bytes.length);
            const result = new Uint8Array(bytes.length);
            let prevByte = key[0];
            for (let i = 0; i < bytes.length; i++) {
                let transformedByte = bytes[i] ^ prevByte ^ key[i % key.length];
                result[i] = transformedByte;
                prevByte = (result[i] + i) % 256;
            }
            return result;
        }

        function railFenceCipher(input, layerIndex) {
            const bytes = input;
            const rails = 3 + (layerIndex % 5);
            const fence = new Array(rails).fill().map(() => []);
            let rail = 0, direction = 1;
            for (let i = 0; i < bytes.length; i++) {
                fence[rail].push(bytes[i]);
                rail += direction;
                if (rail === 0 || rail === rails - 1) direction = -direction;
            }
            const result = new Uint8Array(bytes.length);
            let index = 0;
            for (let r = 0; r < rails; r++) {
                for (let i = 0; i < fence[r].length; i++) {
                    result[index++] = fence[r][i];
                }
            }
            return result;
        }

        function base91Encode(input) {
            console.log('[Hakimi] ğŸ”§ Base91ç¼–ç å¼€å§‹...');
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"";
            const bytes = input;
            let result = '', buffer = 0, bits = 0;
            for (let i = 0; i < bytes.length; i++) {
                buffer |= bytes[i] << bits;
                bits += 8;
                if (bits > 13) {
                    let val = buffer & 8191;
                    if (val > 88) { buffer >>= 13; bits -= 13; }
                    else { val = buffer & 16383; buffer >>= 14; bits -= 14; }
                    result += alphabet[val % 91] + alphabet[Math.floor(val / 91)];
                }
            }
            if (bits > 0) {
                result += alphabet[buffer % 91];
                if (bits > 7 || buffer > 90) result += alphabet[Math.floor(buffer / 91)];
            }
            return result;
        }

        function addUnicodeObfuscation(str) {
            const zwChars = ['\u200B', '\u200C', '\u200D', '\uFEFF'];
            let result = '';
            for (let i = 0; i < str.length; i++) {
                result += str[i];
                if (i % 7 === 0) result += zwChars[i % zwChars.length];
            }
            return result;
        }

        function addChecksum(str) {
            const interval = Math.max(3, Math.floor(str.length / 12));
            let result = '';
            let checksumCount = 0;
            for (let i = 0; i < str.length; i++) {
                result += str[i];
                if ((i + 1) % interval === 0 && checksumCount < 12) {
                    result += String.fromCharCode(65 + (i % 26));
                    checksumCount++;
                }
            }
            return result;
        }

        // ============ ç”Ÿæˆè®¾å¤‡ç  ============
        function generateDeviceCode() {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return Array.from(array, b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        // ============ æ³¨å†Œè®¾å¤‡ç åˆ°åç«¯ ============
        async function registerDeviceCode(deviceCode, characterName) {
            const BACKEND_URL = 'https://theft-prevention-backend.vercel.app';
            try {
                const response = await fetch(`${BACKEND_URL}/api/auth/request`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ deviceCode, characterName })
                });
                const data = await response.json();
                if (data.success) {
                    console.log('[Hakimi] âœ… è®¾å¤‡ç å·²æ³¨å†Œåˆ°äº‘ç«¯');
                    return true;
                } else {
                    console.warn('[Hakimi] âš ï¸ è®¾å¤‡ç æ³¨å†Œå¤±è´¥:', data.message);
                    return false;
                }
            } catch (error) {
                console.warn('[Hakimi] âš ï¸ åç«¯è¿æ¥å¤±è´¥ï¼Œè®¾å¤‡ç æœªæ³¨å†Œï¼ˆé¦–æ¬¡è§£å¯†æ—¶ä¼šè‡ªåŠ¨æ³¨å†Œï¼‰:', error.message);
                return false;
            }
        }

        // ============ ä¸»å¤„ç†å‡½æ•° ============
        async function processCard() {
            if (!fileInput.files.length) {
                showStatus("âŒ è¯·å…ˆç»™çŒ«çŒ«æŠ•å–‚ JSON æ–‡ä»¶ï¼", true);
                return;
            }

            processBtn.disabled = true;
            showStatus("â³ æ­£åœ¨ä¸ºä¸»äººåŠ å¯†...", false);

            const reader = new FileReader();
            reader.readAsText(fileInput.files[0], 'UTF-8');

            reader.onload = async function(e) {
                try {
                    const originalJson = e.target.result;
                    const originalObj = JSON.parse(originalJson);
                    
                    let coreData;
                    if (originalObj.spec === "chara_card_v2" && originalObj.data) {
                        coreData = originalObj.data;
                    } else if (originalObj.data && typeof originalObj.data === 'object') {
                        coreData = originalObj.data;
                    } else {
                        coreData = originalObj;
                    }
                    
                    if (!coreData.name) {
                        throw new Error("è§’è‰²å¡ç¼ºå°‘nameå­—æ®µï¼Œè¯·æ£€æŸ¥JSONæ ¼å¼");
                    }
                    
                    const rawName = coreData.name;
                    let safeName = rawName.replace(/[^\w\u4e00-\u9fa5]/gi, '_'); 
                    const fileName = "LOCKED_" + safeName;
                    
                    // ç”Ÿæˆå”¯ä¸€è®¾å¤‡ç 
                    const deviceCode = generateDeviceCode();

                    console.log("[Hakimi] æ­£åœ¨åŠ å¯†è§’è‰²:", rawName);
                    
                    const cipherText = encodeEightLayers(coreData);
                    
                    if (!cipherText) {
                        throw new Error("åŠ å¯†è¿‡ç¨‹å‡ºé”™");
                    }

                    let cleanedText = cipherText;
                    if (cleanedText.includes('=== DATA START ===')) {
                        const lines = cleanedText.split('\n');
                        const startIdx = lines.findIndex(l => l.includes('=== DATA START ==='));
                        const endIdx = lines.findIndex(l => l.includes('=== DATA END ==='));
                        if (startIdx !== -1 && endIdx !== -1) {
                            cleanedText = lines.slice(startIdx + 1, endIdx).join('\n');
                        }
                    }

                    const CHUNK_SIZE = 8192;
                    const chunks = [];
                    for (let i = 0; i < cleanedText.length; i += CHUNK_SIZE) {
                        chunks.push(cleanedText.substring(i, i + CHUNK_SIZE));
                    }
                    
                    console.log(`[Hakimi] åŠ å¯†æ•°æ®å·²åˆ†ä¸º ${chunks.length} å—`);
                    console.log(`[Hakimi] æ€»é•¿åº¦: ${cleanedText.length} å­—ç¬¦`);

                    const finalCard = {
                        "spec": "chara_card_v2",
                        "spec_version": "2.0",
                        "data": {
                            "name": fileName,
                            "description": "âš ï¸ å…«å±‚DRMä¿æŠ¤å†…å®¹\néœ€è¦å®‰è£…å“ˆåŸºç±³æ’ä»¶æ‰èƒ½æŸ¥çœ‹",
                            "personality": "",
                            "scenario": "",
                            "first_mes": "System: Encrypting...",
                            "mes_example": "",
                            "creator_notes": "HAKIMI_8LAYER::" + cleanedText,
                            "system_prompt": "",
                            "post_history_instructions": "",
                            "tags": ["HAKIMI_DRM_V3"],
                            "creator": "Hakimi_8Layer_v12.1",
                            "character_version": "",
                            "alternate_greetings": [],
                            "extensions": {
                                "hakimi_drm": {
                                    "version": "v12.1",
                                    "chunks": chunks,
                                    "total_length": cleanedText.length,
                                    "checksum": cleanedText.length.toString(16),
                                    "timestamp": Date.now(),
                                    "device_code": deviceCode  // åµŒå…¥è®¾å¤‡ç 
                                }
                            },
                            "character_book": null
                        }
                    };

                    const blob = new Blob([JSON.stringify(finalCard, null, 2)], {type: 'application/json'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName + ".json";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log("[Hakimi] âœ… åŠ å¯†å®Œæˆï¼");
                    console.log("[Hakimi] ğŸ”‘ è®¾å¤‡ç :", deviceCode);
                    
                    // æ³¨å†Œè®¾å¤‡ç åˆ°åç«¯ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ä¸‹è½½ï¼‰
                    registerDeviceCode(deviceCode, rawName).then(registered => {
                        if (registered) {
                            showStatus("âœ… åŠ å¯†å®Œæˆï¼æ–‡ä»¶: " + fileName + ".json | è®¾å¤‡ç : " + deviceCode + " (å·²äº‘ç«¯æ³¨å†Œ)");
                        } else {
                            showStatus("âœ… åŠ å¯†å®Œæˆï¼æ–‡ä»¶: " + fileName + ".json | è®¾å¤‡ç : " + deviceCode + " (æœªè¿æ¥åç«¯)");
                        }
                    });
                    processBtn.disabled = false;

                } catch (err) {
                    console.error("[Hakimi] å¤„ç†å¤±è´¥:", err);
                    showStatus("âŒ å¤„ç†å¤±è´¥: " + err.message, true);
                    processBtn.disabled = false;
                }
            };

            reader.onerror = function() {
                showStatus("âŒ æ–‡ä»¶è¯»å–å¤±è´¥", true);
                processBtn.disabled = false;
            };
        }
        
        function testRoundTrip() {
            // æµ‹è¯•é€»è¾‘çœç•¥ï¼ŒUIå·²éšè—
        }

        // ============ çœŸå®ç‰©ç†è½é›ªç”Ÿæˆè„šæœ¬ ============
        (function createSnow() {
            const snowContainer = document.getElementById('snow-container');
            const snowflakeCount = 80; // å¢åŠ é›ªèŠ±æ•°é‡

            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                
                // 1. éšæœºå¤§å° (3px åˆ° 8px)
                const size = Math.random() * 5 + 3;
                snowflake.style.width = size + 'px';
                snowflake.style.height = size + 'px';
                
                // 2. éšæœºä½ç½®
                snowflake.style.left = Math.random() * 100 + 'vw';
                
                // 3. éšæœºä¸‹è½æ—¶é—´ (5s åˆ° 15s)
                const duration = Math.random() * 10 + 5;
                snowflake.style.animationDuration = `${duration}s, ${Math.random() * 3 + 2}s`; // ä¸‹è½æ—¶é—´, æ‘‡æ‘†æ—¶é—´
                snowflake.style.animationName = 'fall, sway';
                snowflake.style.animationTimingFunction = 'linear, ease-in-out';
                snowflake.style.animationIterationCount = 'infinite, infinite';
                snowflake.style.animationDelay = `-${Math.random() * 10}s`; // è´Ÿå»¶è¿Ÿè®©é›ªèŠ±ä¸€å¼€å§‹å°±å¸ƒæ»¡å±å¹•
                
                // 4. éšæœºæ¨¡ç³Šåº¦ (æ™¯æ·±æ•ˆæœ)
                const blur = Math.random() > 0.6 ? Math.random() * 2 : 0;
                if (blur > 0) {
                    snowflake.style.filter = `blur(${blur}px)`;
                    snowflake.style.opacity = 0.5; // æ¨¡ç³Šçš„é›ªèŠ±é€æ˜ä¸€ç‚¹
                }

                snowContainer.appendChild(snowflake);
            }
        })();
    </script>
</body>
</html>